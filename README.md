# Membership Website with Amplify, Stripe, and Next.js

## Summary:

This project builds a membership website with Amplify, Strip and Next.js. It
allows users to become a member, sign up, sign out, reset passwords by using AWS
Cognito. The website presents a subscription plan linked to a configured product
on Stripe. By clicking "Become a Member", the website will redirect the user to
Stripe checkout page to enter the payment information. An AWS lambda function
listens to the events triggered from Stripe and received by the webhook. Then
Cognito will be triggered to create a user account in the user pool with the
`AdminCreateUser` function. After the user verifies the email, the webiste will
redirect the user to the post component.

## FrontEnd

The front end is based on NEXT.JS, a React framework for building web
applications. Figma is used as a UI tool and can be integrated with Amplify
Studio by linking the Amplify Studio Project to the customized Figma file and
importing the Figma components.

[Figma design file](https://www.figma.com/file/jTMpPiejnjoLihTv663mxa/Membership-Website-for-Amplify-Learn?node-id=1330%3A11587)

### Install Dependencies

The dependencies are installed using the command below:
`npm install aws-amplify @aws-amplify/ui-react @fontsource/inter`

- aws-amplify:
  The AWS Amplify library allows for integration of AWS services such as
  authentication into the application
- @aws-amplify/ui-react:
  The open-source UI library provides UI components that can work with AWS
  Amplify, making it easier to build the user interface
- @fontsource/inter:
  The package allows for tweaking the fonts of the project
  The packages installed are added into the `node_modules` folder and
  `package.json` file.

### Run on localhost

Run the following command in the terminal:
`npm run dev`

### FrontEnd Folder Structure Sample:

- /src
  - /components -> React components used
    - /Layout.js -> Renders the `Nav` component and the `children` prop
  - /pages -> Contains all pages, with each file available as a route
    - /api
    - /\_app.js
    - /\_document.js
    - /index.js
    - /post.js
  - /styles -> Contains the CSS stylesheets for components and pages
    - /Home.module.css -> Includes CSS at component level
    - /reset.css -> Properties from `globals.css` are pasted inside and a
      background color is added
  - /ui-components -> Contains the React code for each of the components in
    Figma such as the Hero compoennt and Nav component
- /public -> Stores publicly accessible files such as the favicon file
- .next -> Autogenerated by Next.js
- aws-exports.js -> Autogenerated at build time and allows the frontend
  application to interact with the backend services
- next.config.js -> Configuration file for Next.js
- package.json -> Contains the project's dependencies and scripts

### Build the Website Pages

- Create a components folder and add `Layout.js` file to the folder

  The `Layout.js` file provides a consistent layout structure that can be
  applied to other pages. Here it is imported into `index.js` and `post.js`.

  ```
  //components/Layout.js
  import React from "react";
  import { View } from "@aws-amplify/ui-react";
  import { Nav } from "../ui-components";
  function Layout({ children, authText, handleClick, username }) {
  return (
      <View width="1200px" marginLeft="auto" marginRight="auto">
      <Nav
          marginTop={"20px"}
          handleAuth={handleClick}
          authText={authText}
          username={username}
          avatar={username.split("")[0].toUpperCase()}
      />
      {children}
      </View>
  );
  }
  export default Layout;
  ```

  In the above code, the `Layout` function which receives props as parameters
  renders the View component as a container for the layout. The `Nav` component
  is rendered inside it and the `children` prop is rendered after the navigation
  component. The Layout component is exported to be used later.

- Modify the `index.js` file

  The `index.js` file defines the structure and the content of the landing page
  of the application.

  ```
  //pages/index.js
  import React from "react";
  import { Flex, View } from "@aws-amplify/ui-react";
  import { Footer, Hero, Persuade, Testimonies } from "../ui-components";
  import Layout from "../components/Layout";
  function Index() {
      return (
          <Layout handleClick={() => {}} authText="Sign Up" username="none">
          <View marginBottom="135px">
              <Hero handleClick={() => {}} />
          </View>
          <View>
              <Testimonies />
          </View>
          <Flex justifyContent={"center"}>
              <Persuade banner="https://i.imgur.com/MxbD3N4.png" />
          </Flex>
          <View marginTop="50px" marginBottom="50px">
              <Footer />
          </View>
          </Layout>
      );
  }
  export default Index;
  ```

  After importing the components and the layout component, the file contains the
  function `Index` that renders the `Hero`, `Testimonies`, `Persuade`, and
  `Footer` components in the layout component, using `View` and `Flex` from the
  React UI framework. The `username` takes the value of `"none"`, so it is not
  visible in the `Nav` component.

- Create a `post.js` file inside `pages`

  This file builds the post page that displays the Stories component which was
  previously binded with the post model.

  ```
  //pages/post.js
  import React from "react";
  import { Heading, Text, View } from "@aws-amplify/ui-react";
  import Layout from "../components/Layout";
  import { Footer, Stories } from "../ui-components";
  function Post() {
  return (
    <Layout
      handleClick={() => {}}
      authText="Sign Out"
      username={"christian@hotmail.com".split("@")[0]}
    >
      <View marginTop="50px" marginBottom="30px">
        <Heading level={2}>Welcome to our backstage</Heading>
        <Text marginTop="20px">
          Discover stories,thinking, and expertise from writers on any top{" "}
        </Text>
      </View>
      <Stories />
      <View marginTop="50px" marginBottom="50px">
        <Footer />
      </View>
    </Layout>
  );
  }
  export default Post;
  ```

  The layout component is applied in the post page, with the `authText` set to
  "Sign Out", the `username` set to christian as a placeholder. Inside the
  layout component, the `View` componenet wraps the `Heading` component, the
  `Text` component, and the `Footer` component. The `Stories` component is
  rendered in between.

- Add more code to the `index.js` file to enable the navigation from the `post`
  page to the landing page.

  ```
  //pages/index.js
  //other imports here
  import { useRouter } from "next/router";
  function Index() {
  const router = useRouter();
  return (
    <Layout
      handleClick={() => {
        router.push("/post");
      }}
      authText="Sign Up"
      username="none"
    >
      //other components implementations here
    </Layout>
  );
  }
  export default Index;
  ```

  First import the `useRouter`. Inside the function `Index()`, the `useRouter()`
  function is used to access a router object which is stored in `router`. In the
  parameter `handleClick`, use the function `router.push` with `"/post"`being
  the parameter for url to navigate users to the post page when the signup
  button is clicked.

### Create UI for Authenticating Users

The `post.js` file needs to be updated to ensure that only users that have
signed in can access the `post` page. To achieve this, use the `Authenticator`
component that adds authentication flows to the application.

```
//pages/post.js
//other imports here
import {Authenticator,Flex,Heading,Text,useTheme,View,} from "@aws-amplify/ui-react";
import { Footer, Logo, Stories } from "../ui-components";
function Post() {

const authComponents = {
    Header() {
      const { tokens } = useTheme();
      return (
        <Flex
          justifyContent={"center"}
          direction="column"
          paddingTop={tokens.space.xxxl}
          paddingBottom={tokens.space.xxl}
        >
          <Logo />
        </Flex>
      );
    },
  };

  return (
    <Authenticator components={authComponents} hideSignUp={true}>
      {({ signOut, user }) => (
        <Layout
          handleClick={() => signOut()}
          authText="Sign Out"
          username={user.attributes.email.split("@")[0]}
        >
          // other components here
        </Layout>
      )}
    </Authenticator>
  );
}
export default Post;
```

In the above code, the `authComponents` contains a `Header` component which
renders a logo component using the `Flex` component. Note that the function
`useTheme()` returns a theme object where design tokens for spacing are defined,
as in `paddingTop` and `paddingBottom`. Then the layout component is wrapped
inside the `Authenticator` component. The `signOut` function and the `user`
object which gives access to the `username` (replacing the previous placeholder)
are passed in as parameters and used in the Layout component.

## BackEnd

Amplify CLI is highly recommended.

### Backend Folder Structure Sample

- /src
  - /models -> Contains files that define data models for the backend database,
    generated by the Amplify DataStore
- /amplify -> Contains AWS backend configurations
  - /backend
    - /api -> Contains code for managing API resources such as `schema.graphql`
      file which defines a collection of types with fields.
    - /auth -> Contains code and configurations for user authentication flow.
      The `cli-inputs.json` is generated during the anuthentication configuration.
    - /function
    - /types
    - backend-config.json -> Specifies the configuration for the backend
      services used for this project
    - tags.json -> Contains tags for organizing AWS resources
  - cli.json -> Contains configuration of feature flags
  - team-provider-info.json

### API and Functions

#### GraphQL API

Two data models, Testimonial and Post, are created with respective fields in the
visual interface of the Amplify Studio. When deploying the database, the Studio
generates a `schema.graphql` GraphQL Transform for the two data models created,
as shown below:

```
type Post @model @auth(rules: [{allow: public}]) {
  id: ID!
  title: String
  body: String
  description: String
  readTime: Int
}

type Testimonial @model @auth(rules: [{allow: public}]) {
  id: ID!
  name: String
  avatar: String
  testimony: String
}
```

Authorization rules are built into the data models. After the deployment of
backend resources completes, the GraphQL API can be used to perform create,
read, update, and delete operations for the two data models. After adding
constraints and auto-generating the data for the data models, the data is stored
in Amazon DynamoDB.

#### AWS Lambda Function

Using the lambda function with Stripe allows for performing tasks such as
processing webhooks. The checkout flow will trigger an AWS Lambda Function that
creates an account for the user. Specifically, the webhook will receive events
from Stripe and perform backend actions in response to events.

- First run the command: `amplify add api`

  - Create a AWS Lambda Function in completing this process
  - Give it access to `auth` so that actions to be performed when authentication
    events occur can be customized
  - Permit `create, read, update, delete` operations on data in the user pool
  - Configure the secret key to be accessed by the Lambda Function so that the
    function has the crendentials to authenticate requests on the server and to
    perform operations

- Navigate to the `/amplify/backend/function/membershipwebsitec452e87a` folder,
  with `membershipwebsitec452e87a` being the file created in the above process
- Install the Stripe client sdk: `npm install aws-sdk stripe`
- Update the `app.js` in `src` directory with the following code, most of which
  is generated when running the `amplify add api` command:

```
const express = require("express");
const bodyParser = require("body-parser");
const awsServerlessExpressMiddleware = require("aws-serverless-express/middleware");
const aws = require("aws-sdk");

// declare a new express app
const app = express();
app.use(
  bodyParser.json({
    verify: function (res, req, buf) {
      req.rawBody = buf.toString();
    },
  })
);
app.use(awsServerlessExpressMiddleware.eventContext());

// Enable CORS for all methods
app.use(function (req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "*");
  next();
});
const getStripeKey = async () => {
  const { Parameters } = await new aws.SSM()
    .getParameters({
      Names: ["stripe_key"].map((secretName) => process.env[secretName]),
      WithDecryption: true,
    })
    .promise();
  return Parameters[0].Value;
};

app.listen(3000, function () {
  console.log("App started");
});
module.exports = app;
```

## Database:

[AWS DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/AccessingDynamoDB.html)
\amplify\backend\api\membershipwebsite\schema.graphql

### Ways to access DynamoDB:

1. Use the [console](https://console.aws.amazon.com/dynamodb/home) in AWS
   management console
2. Use the AWS CLI to perform ad hoc operations, e.g. creating a table
3. Use the API
   Use GraphQL: this is recommended to access and change data that needs to sync
   with database immediately
   Use DataStore: this is recommended to access and change data that does not
   need to sync with database immediately

## Shared Services

### User Authentication: Cognito

_amplify\backend\auth\membershipwebsite\cli-inputs.json_

#### Pre Sign-Up Lambda Trigger:

The pre sign-up lambda trigger is activated shortly before Cognito signs up a
new user to perform custom validation and to accept or deny the user
registration.

1. Used to connect existing account when sign-in with Google, and block sign-up
   when there is already a google account
2. Used to check email alias
3. Used to block unexpected email sign-up
   [Email API](https://www.kleanmail.com/developers)

#### Post Sign-Up Lambda Trigger:

The post sign-up lambda trigger is activated after the new user confirmed. It
can be used to gather new user data.

#### Write the Logic of Webhook and Cognito in Lambda:

The webhook hooks Stripe and the Lambda function together. Once the user
completes the payment, the webhook receives the event from Stripe and triggers
the Lambda Function which creates a new user account in Cognito. The user data
is then written into the Cognito user pool.

In `app.js`, write a post function to handle a webhook endpoint:

```
// post method
app.post("/webhook", async function (req, res) {
  const stripeKey = await getStripeKey();
  const stripe = require("stripe")(stripeKey);
  const customer = await stripe.customers.retrieve(
    req.body.data.object.customer
  );
  const userEmail = customer.email;
  const cognito = new aws.CognitoIdentityServiceProvider({
    apiVersion: "2016-04-18",
  });
  cognito.adminCreateUser(
    {
      UserPoolId: process.env.AUTH_MEMBERSHIPWEBSITE_USERPOOLID,
      Username: userEmail,
      DesiredDeliveryMediums: ["EMAIL"],
      UserAttributes: [
        {
          Name: "email",
          Value: userEmail,
        },
      ],
      ValidationData: [
        {
          Name: "email",
          Value: userEmail,
        },
      ],
    },
    function (err, data) {
      if (err) {
        console.log(err);
      } else {
        console.log(data);
      }
    }
  );
});
```

In the above code, the following is done:

- The Stripe secret key is retrieved by the `getStripeKey()` function for
  authentication
- Calling the `require` function creates the `stripe` object which initializes
  the Stripe SDK
- The `customer` object is retrieved and its `email` attribute is extracted
- Then `adminCreateUser()` method is called to create a new user. Note that the
  `UserAttributes` specifies the user attributes to be set and that
  `ValidationData` specifies the user attributes to be validated
- The functino also handles errors

### Billing Management: Stripe

- Payment Type: Monthly subscription, credits are given per subscription cycle
  and will not carry to next cycle
- Free trial info is managed inside the app and will not sync with Stripe.
- Stripe webhook will use signature verification so for the webhook API Gateway
  address no other Auth is needed and should use raw body for signature
  verification.

#### First time Subscription Payment Flow:

- Navigate to the "Products" tab and create the product
- Save the product price ID
- Both front-end and back-end maintain the price ID, backend maintains stripe
  key and stripe webhook endpoint secret
- Frontend choose subscription plan and call backend with that price ID and a
  redirect address
- Backend uses price ID, redirect address, its own stripe key and customer
  identifier (user email for the first time and stripe customer id for the rest,
  customer id is like remaining credits, they are only editable in backend) to
  request a check-out page address from stripe
- Backend returns this address to front-end, front-end jump out to check-out page
  managed by stripe
- After payment success/fail/cancel, stripe will direct back to our app address
- Stripe will send payment result through webhook (with user information),
  lambda backend will update subscription information based on the result
  (also customer ID is generated by stripe for the first time, store it to database)

#### Link Stripe to Your App

- cd into the membershipwebsite folder
- Install the Stripe client sdk with the command: `npm install @stripe/stripe-js`

##### Get API Key from Stripe

- After creating the product, navigate to the home page
- Save the publishable key and the price id for later use

##### Create Event Handlers and Buttons

- Update the `index.js` file so that user will be redirected to the Stripe
  checkout page to subscribe:

  ```
  //pages/index.js
  //other imports here
  import { loadStripe } from "@stripe/stripe-js";
  function Index() {
  // router here

  async function handleClick() {
      const stripe = await loadStripe(
      "pk_test_51L4jXPKdTSV8bg8w0fz0kimSG031Xoc5jeB4gXeGCt8x7mASfkAYLQzmJSdYNTbQtNIdeHUnJin1xprNw3958ump00e9nhhn9v"
      );
      const { error } = await stripe.redirectToCheckout({
      lineItems: [{ price: "price_1L4lEGKdTSV8bg8wWWfunlGh", quantity: 1 }],
      mode: "subscription",
      successUrl: "http://localhost:3000/post",
      cancelUrl: "http://localhost:3000/cancel",
      });
  }
  return (
      <Layout
      //handleClick here
      authText="Sign Up"
      username="none"
      >
      <View marginBottom="135px">
          <Hero handleClick={handleClick} />
      </View>
      //other components here
      </Layout>
  );
  }
  export default index;
  ```

- In the above code,
  - Import `loadStripe` to load the Stripe.js script
  - Write the `handleClick()` function
    - `loadStripe` is called with the publishable key and returns a Stripe object
    - It then redirects the user to the checkout page
    - Provides the price id, the success and canceled redirect URLs
  - Call the `handleClick()` function in the Hero component

#### Create the Webhook on Stripe

- Copy the endpoint url from `src/aws-exports.js`
- Navigate to the Stripe dashboard, go to `Developers` -> `Webhooks` ->
  `Add an Endpoint`
- Paste the url with the `/webhook` added to the end,
- Click `+ Select events` and choose `payment_intent.succeeded` as the event
  that will trigger the endpoint

## Helpful Resources:

[1] https://amplify.aws/learn/courses/Build-a-Membership-Website-c61a0
[2] https://welearncode.com/stripe-amplify/
[3] https://docs.amplify.aws/
[4] https://stripe.com/docs
[5] https://docs.aws.amazon.com/
